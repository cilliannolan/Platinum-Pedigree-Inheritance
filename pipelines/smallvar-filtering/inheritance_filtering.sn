REF  = "hg38"
TECH = ["dv-hifi", "clair3-hifi", "dnascope-hifi", "dv-ilmn", "dragen-ilmn", "clair3-ont", "pav-assembly"]

def _get_vec(wildcards):
    return config[wildcards.ref]["vec_{tech}".format(tech = wildcards.tech)]

def _get_vcf(wildcards):
    return config[wildcards.ref][wildcards.tech]

def _get_genome(wildcards):
    return config[wildcards.ref]["seq"]

def _get_win(wildcards):
    return config[wildcards.ref]["1mb_win"]

def _get_hq(wildcards):
    return config[wildcards.ref]["hq_regions"]

rule gather:
    input: expand("filtering/{ref}_{tech}.normalized.pedigree_filtered.counts", ref=REF, tech=TECH),
     expand("merged_truth/{ref}/palladium_merged_techs.bcf", ref=REF),
     expand("merged_truth/{ref}/all_variants.bed", ref=REF),
     expand("merged_truth/{ref}/palladium_merged_techs.bed", ref=REF),
     expand("merged_truth/{ref}/hq_regions_final.bed",  ref=REF),
     expand("merged_truth/{ref}/ceph_small_variant_g2g3.vcf", ref=REF),
     expand("merged_truth/{ref}/{parent}_resolver.haps.fasta",ref=REF, parent=["NA12878", "NA12877"] )


rule build_overlap_haplotypes:
    input: vcf="merged_truth/{ref}/ceph_small_variant_g2g3.vcf.gz", ref=_get_genome, regions="merged_truth/{ref}/{parent}_to_resolve.regions", resolver=config['resolver']
    output: "merged_truth/{ref}/{parent}_resolver.haps.fasta"
    shell: """
        {input.resolver} --fasta {input.ref} --vcf {input.vcf} --sample {wildcards.parent} --region {input.regions} --prefix merged_truth/{wildcards.ref}/{wildcards.parent}_resolver
    """

rule build_regions_to_resolve:
    input: ovls="merged_truth/{ref}/{parent}_resolver.ovls.bed", genomic_regions=config['2kwindows']
    output: "merged_truth/{ref}/{parent}_to_resolve.regions"
    shell: """
        bedtools intersect -c -a {input.genomic_regions} -b {input.ovls} | perl -lane 'print if $F[-1] > 0' | perl -lane 'print "$F[0]:$F[1]-$F[2]"' > {output}
    """

rule identify_overlaps:
    input: vcf="merged_truth/{ref}/ceph_small_variant_g2g3.vcf.gz", ref=_get_genome, region_fn=config['regions_for_resolver'], resolver=config['resolver']
    output: "merged_truth/{ref}/{parent}_resolver.ovls.txt", "merged_truth/{ref}/{parent}_resolver.ovls.bed"
    shell: """

        {input.resolver} --fasta {input.ref} --vcf {input.vcf} --sample {wildcards.parent} --region {input.region_fn} --prefix merged_truth/{wildcards.ref}/{wildcards.parent}_resolver -d
        sort merged_truth/{wildcards.ref}/{wildcards.parent}_resolver.ovls.txt | perl -lane 'print "$F[0]\\t$F[1]\\t$F[1]"' | sort | uniq  > merged_truth/{wildcards.ref}/{wildcards.parent}_resolver.ovls.bed
    """

rule prep_compressed_vcf:
    input: vcf="merged_truth/{ref}/ceph_small_variant_g2g3.vcf", ref=_get_genome
    output: "merged_truth/{ref}/ceph_small_variant_g2g3.vcf.gz"
    shell: """
        bcftools reheader -f {input.ref}.fai {input.vcf} |  bcftools view -f 'PASS' - -O b | bcftools view  -e 'INFO/SC == 1 &  ( INFO/SOURCES ~ "assembly" | INFO/SOURCES ~ "dnascope")' - |  bcftools sort -O z -o {output}
        bcftools index {output[0]}

    """

rule create_vcf:
    input: mash=config['mash'], data="merged_truth/{ref}/mashed.txt"
    output: "merged_truth/{ref}/ceph_small_variant_g2g3.vcf"
    shell: """
        {input.mash} --mashed {input.data} --samples NA12879,NA12881,NA12882,NA12883,NA12884,NA12885,NA12886,NA12887,NA12877,NA12878 --prefix merged_truth/{wildcards.ref}/ceph_small_variant_g2g3 --ik clair3_ont,clair3_hifi,deep_var_hifi,dnascope_hifi,deep_var_ilmn,dragen_ilmn,pav_asm
    """

rule merge_n_mash:
    input: expand("merged_truth/{{ref}}/{tech}.normalized.pedigree_filtering.tagged.sites", tech=TECH)
    output: "merged_truth/{ref}/mashed.txt"
    shell:  """
        cat {input} | sort -k1,1 | datamash -g 1 collapse 2,3 > {output}
    """

rule tag_sites:
    input: sites="filtering/{ref}_{tech}.normalized.pedigree_filtering.sites"
    output: "merged_truth/{ref}/{tech}.normalized.pedigree_filtering.tagged.sites"
    shell: """
        perl -lane 'print "$_\\t{wildcards.tech}"' {input} > {output}
    """

rule count:
    input: "filtering/{ref}_{tech}.normalized.pedigree_filtered_sorted.bcf"
    output: "filtering/{ref}_{tech}.normalized.pedigree_filtered.counts"
    shell: """
        bcftools +counts {input} > {output}
    """

rule win_count:
    input: bcf="filtering/{ref}_{tech}.normalized.pedigree_filtered_sorted.bcf", win=_get_win
    output: "filtering/{ref}_{tech}.normalized.pedigree_filtered_counts.bed"
    shell: """
        bcftools view {input.bcf} > {wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtered_sorted.vcf
        bedtools intersect -c -a {input.win} -b {wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtered_sorted.vcf > {output}
    """

rule refine_hq_regions:
    input: ped_var="merged_truth/{ref}/palladium_merged_techs.bed", hq="merged_truth/{ref}/hq_regions_no_vars.bed"
    output: "merged_truth/{ref}/hq_regions_final.bed"
    shell: """
        cat {input.ped_var} {input.hq} | sort -k1,1 -k2,2n | bedtools merge -i - > {output}
    """

rule make_tpvar_bed:
    input: bcf="merged_truth/{ref}/palladium_merged_techs.bcf", genome=_get_genome
    output: "merged_truth/{ref}/palladium_merged_techs.bed"
    shell: """
          bcftools query -f '%CHROM\\t%POS0\\t%END\\n' {input.bcf}  > {output}
    """

rule merge_filtered:
    input: expand("filtering/{{ref}}_{tech}.normalized.pedigree_filtered_sorted.bcf", tech=TECH)
    output: "merged_truth/{ref}/palladium_merged_techs.bcf"
    shell: """
        bcftools concat -O b -a -d all {input} > {output}
    """

rule pedigree_filter:
     input: con=config['concordance'], bcf="filtering/{ref}_{tech}.normalized.sorted.bcf", vector=_get_vec
     output: "filtering/{ref}_{tech}.normalized.pedigree_filtered_sorted.bcf", "filtering/{ref}_{tech}.normalized.pedigree_filtering.sites"
     shell: """
            {input.con} -i {input.vector} -v {input.bcf} -p filtering/{wildcards.ref}_{wildcards.tech}.normalized_pedigree_filtered > filtering/{wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtering.info.out
            bcftools sort --output-type b filtering/{wildcards.ref}_{wildcards.tech}.normalized_pedigree_filtered.vcf > {output[0]}
            bcftools index {output[0]}
            bcftools query -f '%CHROM:%POS0:%END:%REF:%ALT\t[%GT:]\n' {output[0]} > {output[1]}
     """

rule subtract_all_vars_hq:
    input: hq=_get_hq, vars="merged_truth/{ref}/all_variants.bed"
    output: "merged_truth/{ref}/hq_regions_no_vars.bed"
    shell: """
        bedtools subtract -a {input.hq} -b {input.vars} > {output}
    """

rule merge_beds:
    input: expand( "filtering/{{ref}}_{tech}.normalized.sorted.bed",  tech=TECH)
    output: "merged_truth/{ref}/all_variants.bed"
    shell: """
        cat {input} | sort -k1,1 -k2,2n  > {output}
    """

rule make_beds:
    input:  bcf="filtering/{ref}_{tech}.normalized.sorted.bcf", genome=_get_genome
    output: "filtering/{ref}_{tech}.normalized.sorted.bed"
    shell: """
        bcftools query -f '%CHROM\\t%POS0\\t%END\\n' {input.bcf}  > {output}
    """
         
rule norm:
    input:  vcf=_get_vcf, genome=_get_genome
    output: "filtering/{ref}_{tech}.normalized.sorted.bcf"
    threads: 8
    shell: """
        bcftools view --max-alleles 4 -i '(ILEN > -50 && ILEN < 50 || type="snp")' --output-type b {input.vcf} | bcftools norm --multiallelic - --threads {threads} --output-type b --fasta-ref {input.genome} - | bcftools sort --output-type b -o {output}
        bcftools index {output}
    """