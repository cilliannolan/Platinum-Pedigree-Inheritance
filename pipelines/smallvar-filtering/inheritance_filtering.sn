REF  = "hg38"
TECH = ["hifi", "ilmn", "ont", "assembly", "dragen", "clair3hifi", "dnascope"]

def _get_vec(wildcards):
    return config[wildcards.ref]["vec_{tech}".format(tech = wildcards.tech)]

def _get_vcf(wildcards):
    return config[wildcards.ref][wildcards.tech]

def _get_genome(wildcards):
    return config[wildcards.ref]["seq"]

def _get_win(wildcards):
    return config[wildcards.ref]["1mb_win"]

def _get_hq(wildcards):
    return config[wildcards.ref]["hq_regions"]

rule gather:
    input: expand("{ref}_{tech}.normalized.pedigree_filtered.counts", ref=REF, tech=TECH),
     expand("{ref}_{tech}.normalized.pedigree_filtering.info.out", ref=REF, tech=TECH), 
     expand("{ref}_{tech}.normalized.pedigree_filtered.counts.bed",ref=REF, tech=TECH), 
     expand("{ref}_{tech}.normalized.na12878.counts",ref=REF, tech=TECH),
     expand("{ref}_{tech}.normalized.pedigree_filtered.na12878.counts",ref=REF, tech=TECH),
     expand("merged_truth/{ref}/palladium_merged_techs.bcf", ref=REF),
     expand("merged_truth/{ref}/all_na12878_variants.bed", ref=REF),
     expand("merged_truth/{ref}/palladium_merged_techs.bed", ref=REF),
     expand("merged_truth/{ref}/hq_regions_final.bed",  ref=REF),
     expand("merged_truth/{ref}/ceph_small_variant_g2g3.vcf", ref=REF),
     expand("merged_truth/{ref}/{parent}_haps.haps.fasta",ref=REF, parent=["NA12878", "NA12877"] )


rule build_overlap_haplotypes:
    input: vcf="merged_truth/{ref}/ceph_small_variant_g2g3.vcf.gz", ref=_get_genome, regions="merged_truth/{ref}/{parent}_to_resolve.regions", resolver=config['resolver']
    output: "merged_truth/{ref}/{parent}_haps.haps.fasta"
    shell: """
        {input.resolver} --fasta {input.ref} --vcf {input.vcf} --sample {wildcards.parent} --region {input.region_fn} --prefix merged_truth/{wildcards.ref}/{wildcards.parent}_resolver_haps
    """

rule build_regions_to_resolve:
    input: ovls="merged_truth/{ref}/{parent}_resolver.ovls.bed", genomic_regions=config['2kwindows']
    output: "merged_truth/{ref}/{parent}_to_resolve.regions"
    shell: """
        bedtools intersect -c -a {input.genomic_regions} -b {input.ovls} | perl -lane 'print if $F[-1] > 0' | perl -lane 'print "$F[0]:$F[1]-$F[2]"' > {output}
    """

rule identify_overlaps:
    input: vcf="merged_truth/{ref}/ceph_small_variant_g2g3.vcf.gz", ref=_get_genome, region_fn=config['regions_for_resolver'], resolver=config['resolver']
    output: "merged_truth/{ref}/{parent}_resolver.ovls.txt", "merged_truth/{ref}/{parent}_resolver.ovls.bed"
    shell: """
        {input.resolver} --fasta {input.ref} --vcf {input.vcf} --sample {wildcards.parent} --region {input.region_fn} --prefix merged_truth/{wildcards.ref}/{wildcards.parent}_resolver -d
        sort merged_truth/{wildcards.ref}/{wildcards.parent}_resolver.ovls.txt | perl -lane 'print "$F[0]\\t$F[1]\\t$F[1]"' | sort | uniq  > merged_truth/{wildcards.ref}/{wildcards.parent}_resolver.ovls.bed
    """

rule prep_compressed_vcf:
    input: vcf="merged_truth/{ref}/ceph_small_variant_g2g3.vcf", ref=_get_genome
    output: "merged_truth/{ref}/ceph_small_variant_g2g3.vcf.gz"
    shell: """
        bcftools reheader -f {input.ref}.fai {input.vcf} |  bcftools view -f 'PASS' - -O b |  bcftools sort -O z -o {output}
        bcftools index {output}
    """

rule create_vcf:
    input: mash=config['mash'], data="merged_truth/{ref}/mashed.txt"
    output: "merged_truth/{ref}/ceph_small_variant_g2g3.vcf"
    shell: """
        {input.mash} --mashed {input.data} --samples NA12879,NA12881,NA12882,NA12883,NA12884,NA12885,NA12886,NA12887,NA12877,NA12878 --prefix merged_truth/{wildcards.ref}/ceph_small_variant_g2g3 --ik clair3_ont,clair3_hifi,deep_var_hifi,dnascope_hifi,deep_var_ilmn,dragen_ilmn,pav_asm
    """

rule merge_n_mash:
    input: expand("merged_truth/{{ref}}/{tech}.normalized.pedigree_filtering.tagged.sites", tech=TECH)
    output: "merged_truth/{ref}/mashed.txt"
    shell:  """
        cat {input} | sort -k1,1 | datamash -g 1 collapse 2,3 > {output}
    """

rule tag_sites:
    input: sites="{ref}_{tech}.normalized.pedigree_filtering.sites"
    output: "merged_truth/{ref}/{tech}.normalized.pedigree_filtering.tagged.sites"
    shell: """
        perl -lane 'print "$_\\t{wildcards.tech}"' {input} > {output}
    """

rule refine_hq_regions:
    input: ped_var="merged_truth/{ref}/palladium_merged_techs.bed", hq="merged_truth/{ref}/hq_regions_no_vars.bed"
    output: "merged_truth/{ref}/hq_regions_final.bed"
    shell: """
        cat {input.ped_var} {input.hq} | sort -k1,1 -k2,2n | bedtools merge -i - > {output}
    """

rule venn_counts:
    input: "venn_{ref}/000{ven}.vcf", 
    output: "venn_{ref}/000{ven}.counts",
    shell: """
        bcftools +counts {input} > {output}
    """

rule venn:
    input: expand("{{ref}}_{tech}.normalized.pedigree_filtered.bcf", tech=TECH)
    output: "venn_{ref}/000{ven}.vcf"
    shell: """
        bcftools isec -p venn_{wildcards.ref} {input}
    """

rule count:
    input: "{ref}_{tech}.normalized.pedigree_filtered.sorted.bcf"
    output: "{ref}_{tech}.normalized.pedigree_filtered.counts"
    shell: """
        bcftools +counts {input} > {output}
    """

rule win_count:
    input: bcf="{ref}_{tech}.normalized.pedigree_filtered.sorted.bcf", win=_get_win
    output: "{ref}_{tech}.normalized.pedigree_filtered.counts.bed"
    shell: """
        bcftools view {input.bcf} > {wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtered.sorted.vcf
        bedtools intersect -c -a {input.win} -b {wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtered.sorted.vcf > {output}
    """

rule na12878_count_pedigree_filter:
    input: "{ref}_{tech}.normalized.pedigree_filtered.na12878.sorted.bcf"
    output: "{ref}_{tech}.normalized.pedigree_filtered.na12878.counts"
    shell: """
        bcftools +counts {input} > {output}
    """

rule make_tp_na12878_bed:
    input: bcf="merged_truth/{ref}/palladium_merged_techs.bcf", genome=_get_genome
    output: "merged_truth/{ref}/palladium_merged_techs.bed"
    shell: """
          bcftools query -f '%CHROM\\t%POS0\\t%END\\n' {input.bcf}  > {output}
    """

rule merge_na12878_filtered:
    input: expand("{{ref}}_{tech}.normalized.pedigree_filtered.na12878.sorted.bcf", tech=TECH)
    output: "merged_truth/{ref}/palladium_merged_techs.bcf"
    shell: """
        bcftools concat -O b -a -d all {input} > {output}
    """

rule na12878_extract_filtered:
    input: "{ref}_{tech}.normalized.pedigree_filtered.sorted.bcf"
    output: "{ref}_{tech}.normalized.pedigree_filtered.na12878.sorted.bcf"
    shell: """
        bcftools view -s NA12878 -O b {input} | bcftools view -O b -i 'GT[*]="alt"' > {output}
        bcftools index {output}
    """

rule pedigree_filter:
     input: config['concordance'], vcf="{ref}_{tech}.normalized.sorted.bcf", vector=_get_vec
     output: "{ref}_{tech}.normalized.pedigree_filtered.sorted.bcf", "{ref}_{tech}.normalized.pedigree_filtering.info.out", "{ref}_{tech}.normalized.pedigree_filtering.sites"
     shell: """
            bcftools view {wildcards.ref}_{wildcards.tech}.normalized.sorted.bcf > {wildcards.ref}_{wildcards.tech}.normalized.sorted.vcf
            {input.con} -i {input.vector} -v {wildcards.ref}_{wildcards.tech}.normalized.sorted.vcf -p {wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtered > {wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtering.info.out
            bcftools sort --output-type b {wildcards.ref}_{wildcards.tech}.normalized.pedigree_filtered.vcf > {output[0]}
            bcftools index {output[0]}
            bcftools query -f '%CHROM:%POS0:%END:%REF:%ALT\t[%GT:]\n' {output[0]} > {output[2]}
     """

rule na12878_counts:
    input: "{ref}_{tech}.normalized.na12878.sorted.bcf"
    output: "{ref}_{tech}.normalized.na12878.counts"
    shell: """
        bcftools +counts {input} > {output}
    """

rule na12878_extract_normalized:
    input: vcf=_get_vcf, genome=_get_genome
    output: "{ref}_{tech}.normalized.na12878.sorted.bcf"
    shell: """
        bcftools view -s NA12878 -O b {input.vcf} | bcftools view -O b -i 'GT[*]="alt"' | bcftools norm --multiallelic - --threads {threads} --output-type b --fasta-ref {input.genome} | bcftools sort --output-type b > {output}
        bcftools index {output}
    """

rule subtract_all_vars_hq:
    input: hq=_get_hq, vars="merged_truth/{ref}/all_na12878_variants.bed"
    output: "merged_truth/{ref}/hq_regions_no_vars.bed"
    shell: """
        bedtools subtract -a {input.hq} -b {input.vars} > {output}
    """

rule merge_beds:
    input: expand( "{{ref}}_{tech}.normalized.na12878.sorted.bed",  tech=TECH)
    output: "merged_truth/{ref}/all_na12878_variants.bed"
    shell: """
        cat {input} | sort -k1,1 -k2,2n  > {output}
    """

rule make_beds:
    input:  bcf="{ref}_{tech}.normalized.na12878.sorted.bcf", genome=_get_genome
    output: "{ref}_{tech}.normalized.na12878.sorted.bed"
    shell: """
        bcftools query -f '%CHROM\\t%POS0\\t%END\\n' {input.bcf}  > {output}
    """
         
rule norm:
    input:  vcf=_get_vcf, genome=_get_genome
    output: "{ref}_{tech}.normalized.sorted.bcf"
    threads: 8
    shell: """
        bcftools view --max-alleles 4 -i '(ILEN > -50 && ILEN < 50 || type="snp")' --output-type b {input.vcf} | bcftools norm --multiallelic - --threads {threads} --output-type b --fasta-ref {input.genome} - | bcftools sort --output-type b -o {output}
        bcftools index {output}
    """

rule bt:
     output: "concordance"
     shell: """
            cargo build --release --manifest-path ../code/concordance/Cargo.toml
            mv ../code/concordance/target/release/concordance .
     """